function Generate-ThirdPartyNotices {
    <#
    .SYNOPSIS
    Generates a visually formatted THIRD-PARTY-NOTICES.txt file from a NuGet license JSON.

    .DESCRIPTION
    Reads the `licenses.json` generated by `dotnet nuget-license` and extracts
    package name, version, license type, URL, and authors. It formats them
    into a structured THIRD-PARTY-NOTICES.txt file.

    If any package contains `ValidationErrors`, the script will throw an error and exit.

    .PARAMETER LicenseJsonPath
    Path to the JSON file containing NuGet license information.

    .PARAMETER OutputPath
    Path where the THIRD-PARTY-NOTICES.txt file should be created.

    .EXAMPLE
    Generate-ThirdPartyNotices -LicenseJsonPath "licenses.json" -OutputPath "THIRD-PARTY-NOTICES.txt"

    Generates a THIRD-PARTY-NOTICES.txt file based on `licenses.json`.
    #>
    param(
        [string]$LicenseJsonPath = "licenses.json",
        [string]$OutputPath = "THIRD-PARTY-NOTICES.txt"
    )

    if (!(Test-Path $LicenseJsonPath)) {
        Write-Host "Error: License JSON file not found at $LicenseJsonPath" -ForegroundColor Red
        exit 1
    }

    # Read and parse JSON
    $licenses = Get-Content $LicenseJsonPath | ConvertFrom-Json

    # Check for validation errors
    $hasErrors = $false
    foreach ($package in $licenses) {
        if ($package.ValidationErrors.Count -gt 0) {
            $hasErrors = $true
            Write-Host "License validation error in package: $($package.PackageId) - $($package.PackageVersion)" -ForegroundColor Red
            foreach ($errors in $package.ValidationErrors) {
                Write-Host "   $errors" -ForegroundColor Yellow
            }
        }
    }

    if ($hasErrors) {
        Write-Host "Exiting due to license validation errors." -ForegroundColor Red
        exit 1
    }

    # Prepare the notice text
    $notices = @()
    $notices += "============================================"
    $notices += "          THIRD-PARTY LICENSE NOTICES       "
    $notices += "============================================"
    $notices += "`nThis project includes third-party libraries under open-source licenses.`n"

    foreach ($package in $licenses) {
        $name = $package.PackageId
        $version = $package.PackageVersion
        $license = $package.License
        $url = $package.LicenseUrl
        $authors = $package.Authors
        $packageProjectUrl = $package.PackageProjectUrl

        $notices += "--------------------------------------------"
        $notices += "üì¶ Package: $name (v$version)"
        $notices += "üîñ License: $license"
        if ($url) { $notices += "üåç License URL: $url" }
        if ($authors) { $notices += "üë§ Authors: $authors" }
        if ($packageProjectUrl) { $notices += "üîó Project: $packageProjectUrl" }
        $notices += "--------------------------------------------`n"
    }

    # Write to file
    $notices | Out-File -Encoding utf8 $OutputPath

    Write-Host "THIRD-PARTY-NOTICES.txt generated at: $OutputPath" -ForegroundColor Green
}


function Replace-FilePlaceholders {
    <#
    .SYNOPSIS
    Reads a file, replaces placeholders with specified values, and writes the result to another file using System.IO.
    
    .DESCRIPTION
    This function reads the entire content of an input file, replaces placeholders of the form 
    {{PlaceholderName}} with corresponding values provided in a hashtable, and saves the modified content 
    to an output file using the .NET System.IO.File class.
    
    .PARAMETER InputFile
    The full path of the input file that contains placeholders.
    
    .PARAMETER OutputFile
    The full path where the rendered file will be saved.
    
    .PARAMETER Replacements
    A hashtable with keys matching the placeholder names (without the curly braces) and values as the replacement strings.
    
    .EXAMPLE
    $replacements = @{
        "sourceCodeDirectory" = "C:\Projects\MyApp"
        "outputDirectory"     = "C:\Output"
    }
    Replace-FilePlaceholders -InputFile "C:\Templates\template.json" -OutputFile "C:\Rendered\output.json" -Replacements $replacements
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$InputFile,
        
        [Parameter(Mandatory = $true)]
        [string]$OutputFile,
        
        [Parameter(Mandatory = $true)]
        [hashtable]$Replacements
    )
    
    # Validate that the input file exists
    if (-not (Test-Path -Path $InputFile)) {
        Write-Error "Input file '$InputFile' does not exist."
        return
    }

    
    
    try {
        # Read the entire content of the input file using System.IO
        $content = [System.IO.File]::ReadAllText($InputFile)
        
        # Iterate through each key/value pair in the replacements hashtable
        foreach ($key in $Replacements.Keys) {
            # Build the regex pattern for the placeholder (e.g. {{sourceCodeDirectory}})
            $pattern = [regex]::Escape("{{" + $key + "}}")
            # Replace all occurrences of the placeholder with its value
            $current = $Replacements[$key] -replace '\\', '/'
            $content = [regex]::Replace($content, $pattern, $current)
        }
        
        # Save the modified content to the output file using System.IO
        [System.IO.File]::WriteAllText($OutputFile, $content)
        
        Write-Host "File processed successfully. Output saved to '$OutputFile'."
    }
    catch {
        Write-Error "An error occurred: $_"
    }
}

